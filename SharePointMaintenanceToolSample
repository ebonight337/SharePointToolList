using System;
using System.Net;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security;
using System.Threading;
using System.Threading.Tasks;
using SP = Microsoft.SharePoint.Client;

namespace SharePointMaintenanceToolSample {
    /// <summary>
    /// SharePoint のデータ操作機能を提供します
    /// </summary>
    public class SharePointDataService : IDisposable {
        private readonly SP.ClientContext _context;
        private readonly SecureString _secureString;

        /// <summary>
        /// 操作対象の ClientContext を取得します
        /// </summary>
        public SP.ClientContext ClientContext => _context;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        /// <param name="sitePath">データ操作対象のサイト URL</param>
        /// <param name="mailAddress">データ操作を行うユーザーメールアドレス</param>
        /// <param name="password">データ操作を行うユーザーパスワード</param>
        public SharePointDataService(string sitePath, string mailAddress, string password) {
            _context = new SP.ClientContext(sitePath);

            _secureString = new SecureString();
            password.ToList().ForEach(c => _secureString.AppendChar(c));
            _context.Credentials = new SP.SharePointOnlineCredentials(mailAddress, _secureString);
        }



        /*
         * ここに利用するメソッドを記載していきます。
         */
         
            

        /// <summary>
        /// インスタンスの破棄処理を行います
        /// </summary>
        public void Dispose() {
            _context?.Dispose();
            _secureString?.Dispose();
        }
    }


    static class ExecuteQuery {
        /// <summary>
        /// ExecuteQueryを実行する際に挟むメソッドSPの「調整」対策
        /// </summary>
        /// <param name="clientContext"></param>
        /// <param name="retryCount"></param>
        /// <param name="delay"></param>
        public static async Task ExecuteQueryWithIncrementalRetry(this SP.ClientContext clientContext, int retryCount = 5, int delay = 30000) {
            int retryAttempts = 0;
            int backoffInterval = delay;
            int retryAfterInterval = 0;
            bool retry = false;
            SP.ClientRequestWrapper wrapper = null;
            if (retryCount <= 0)
                throw new ArgumentException("0より大きい試行回数を設定してください");
            if (delay <= 0)
                throw new ArgumentException("0より大きい遅延を設定してください");

            // 再試行の再試行回数をモニター
            while (retryAttempts < retryCount) {
                try {
                    if (!retry) {
                        await clientContext.ExecuteQueryAsync();
                        return;
                    } else {
                        // リクエストを再試行する
                        if (wrapper != null && wrapper.Value != null) {
                            clientContext.RetryQuery(wrapper.Value);
                            return;
                        }
                    }
                } catch (WebException ex) {
                    var response = ex.Response as HttpWebResponse;
                    // Check if request was throttled - http status code 429
                    // Check is request failed due to server unavailable - http status code 503
                    if (response != null && (response.StatusCode == (HttpStatusCode)429 || response.StatusCode == (HttpStatusCode)503)) {
                        wrapper = (SP.ClientRequestWrapper)ex.Data["ClientRequest"];
                        retry = true;

                        // 利用可能な場合には再試行後のヘッダーを使用する
                        string retryAfterHeader = response.GetResponseHeader("Retry-After");
                        if (!string.IsNullOrEmpty(retryAfterHeader)) {
                            if (!Int32.TryParse(retryAfterHeader, out retryAfterInterval)) {
                                retryAfterInterval = backoffInterval;
                            }
                        } else {
                            retryAfterInterval = backoffInterval;
                        }

                        // 指定されたミリ秒分遅らせる
                        Thread.Sleep(retryAfterInterval);

                        // Increase counters
                        retryAttempts++;
                        backoffInterval = backoffInterval * 2;
                    } else {
                        throw;
                    }
                }
            }
            throw new MaximumRetryAttemptedException($"Maximum retry attempts {retryCount}, has be attempted.");
        }

        [Serializable]
        public class MaximumRetryAttemptedException : Exception {
            public MaximumRetryAttemptedException(string message) : base(message) { }
        }

    }
}
 
